---
layout: default
---

# Chương 14 - Sự phụ thuộc vào thư viện đang giết chết tôi.

Một điều thực sự giúp ích cho việc phát triển là tái sử dụng code. Nếu chúng ta có thể mua một thư viện giải quyết được một số vấn đề cho chúng ta (và tìm ra cách sử dụng nó), chúng ta thường có thể cắt giảm đáng kể thời gian thực hiện một dự án. Vấn đề duy nhất là rất dễ trở nên quá phụ thuộc vào thư viện. Nếu bạn sử dụng nó một cách bừa bãi trong toàn bộ code của mình, bạn sẽ sớm mắc kẹt với nó. Một số đội nhóm mà tôi từng làm việc cùng đã bị ảnh hưởng nặng nề do phụ thuộc quá nhiều vào thư viện. Trong một trường hợp, một nhà cung cấp thư viện đã tăng phí bản quyền cao đến mức ứng dụng không thể có được lợi nhuận. Đội nhóm đó không thể dễ dàng sử dụng thư viện của nhà cung cấp khác vì việc tách các lệnh gọi đến code của nhà cung cấp ban đầu sẽ dẫn đến việc viết lại khá nhiều.

> Tránh thực hiện các lệnh gọi trực tiếp đến các lớp thư viện trong code của bạn. Bạn có thể tưởng rằng sẽ không bao giờ thay đổi chúng, nhưng điều đó có thể trở thành một lời tiên tri tự ứng nghiệm.

Tại thời điểm viết bài này, phần lớn thế giới lập trình đang xoay xung quanh Java và .NET. Cả Microsoft và Sun đều cố gắng phát triển nền tảng của họ càng rộng càng tốt, tạo ra càng nhiều thư viện để mọi người tiếp tục sử dụng sản phẩm của họ. Theo một cách nào đó, đó là một lợi thế cho nhiều dự án, nhưng bạn vẫn có thể dựa quá nhiều vào các thư viện cụ thể. Mỗi lần sử dụng lớp thư viện được code cứng là một lần bạn có thể có một đường nối. Một số thư viện rất giỏi trong việc xác định giao diện cho tất cả các lớp cụ thể của chúng. Trong các trường hợp khác, các lớp là cụ thể và được khai báo là `final` hoặc `sealed` hoặc chúng có các chức năng chính không ảo, không có cách nào để giả mạo chúng khi kiểm thử. Trong những trường hợp này, đôi khi điều tốt nhất bạn có thể làm là viết một lớp bao bọc lên các lớp mà bạn cần tách ra. Hãy đảm bảo rằng bạn thông báo cho nhà cung cấp của mình và khiến họ đau buồn vì đã khiến công việc phát triển của bạn trở nên khó khăn.

> Các nhà thiết kế thư viện sử dụng các tính năng ngôn ngữ để thực thi các ràng buộc thiết kế thường mắc lỗi. Họ quên rằng code tốt sẽ chạy trong môi trường sản xuất và kiểm thử. Những ràng buộc đối với cái trước có thể khiến việc làm trong cái sau gần như không thể thực hiện được.

Có sự căng thẳng cơ bản giữa các tính năng ngôn ngữ cố gắng thực thi thiết kế tốt và những việc bạn phải làm để kiểm thử code. Một trong những căng thẳng phổ biến nhất là `song đề duy nhất`. Nếu thư viện giả định rằng sẽ chỉ có một phiên bản của lớp trong hệ thống, điều đó có thể khiến việc sử dụng các đối tượng giả trở nên khó khăn. Có thể không có cách nào để sử dụng _Giới thiệu Static Setter (372)_ hoặc nhiều kỹ thuật phá vỡ phụ thuộc khác mà bạn có thể sử dụng để xử lý các singleton. Đôi khi bọc singleton là sự lựa chọn duy nhất dành cho bạn.

Một vấn đề khác là vấn đề _song đề hạn chế ghi đè_. Trong một số ngôn ngữ OO, tất cả các phương thức đều là ảo. Ở những nơi khác, chúng là ảo theo mặc định, nhưng chúng có thể được chuyển thành không ảo. Ở những nơi khác, bạn phải biến chúng thành ảo một cách rõ ràng. Từ góc độ thiết kế, có một số giá trị trong việc biến một số phương thức thành không ảo. Đôi khi, nhiều người trong ngành đã khuyến nghị nên tạo càng nhiều phương thức phi ảo càng tốt. Đôi khi những lý do họ đưa ra là chính đáng, nhưng khó có thể phủ nhận rằng cách làm này gây khó khăn cho việc đưa cảm biến và phân tách vào code base. Cũng khó có thể phủ nhận rằng mọi người thường viết code rất tốt trong Smalltalk, nơi mà việc đó là không thể; ở Java, nơi mọi người thường không làm điều đó; và thậm chí cả trong C++, nơi có rất nhiều code được viết mà không có nó. Bạn có thể làm rất tốt việc giả vờ rằng một phương thức công khai không phải là ảo trong code sản xuất. Nếu bạn làm điều đó, bạn có thể ghi đè nó một cách có chọn lọc trong quá trình thử nghiệm và tận dụng tối đa cả hai.

> Đôi khi sử dụng quy ước code cũng tốt như sử dụng tính năng hạn chế ngôn ngữ. Hãy suy nghĩ về những gì kiểm thử của bạn cần.
